from packages.help.help import help

class core_help(help):
    def __init__(self, output):
        super().__init__(output)
        self.help_dict = {'dup' : 'Duplicate the top value in work stack and put it on top\nUsage : ( n ... ) DUP ( n n ... )',
                          '2dup' : 'Duplicate the two top values in work stack and put it on top\nUsage : ( n1 n2 ... ) 2DUP ( n1 n2 n1 n2 ... )',
                          'swap' : 'swap the two top value in work stack\nUsage : ( n1 n2 ... ) SWAP ( n2 n1 ... )',
                          '2swap' : 'swap the two top value with the two after in work stack\nUsage : ( n1 n2 n3 n4 ... ) 2SWAP ( n3 n4 n2 n1 ... )',
                          'over' : 'Take the second top value in work stack and put it on the top\nUsage : ( n1 n2 ... ) OVER ( n2 n1 n2 ... )',
                          '2over' : 'Take the second top value after the two top value in work stack and put it on the top\nUsage : ( n1 n2 n3 n4 ... ) 2OVER ( n3 n4 n1 n2 n3 n4 ... )',
                          'rot' : 'Rotate the third top values in work stack\nUsage : ( n1 n2 n3 ... ) ROT ( n3 n1 n2 ... )',
                          '.' : 'Display the top value of work stack and destroy it\nUsage : ( n ... ) . ( ... )',
                          '.s' : 'Display the top value of work stack and do not destroy it\nUsage : ( n ... ) .s ( n ... )',
                          ':' : 'Mark the begin of word definition and nothing is do on work stack\nUsage :\n   : name[ ( comment ) ] instructions ;',
                          ';' : 'Mark the end of word definition and nothing is do on work stack\nUsage :\n   : name[ ( comment ) ] instructions ;',
                          '(' : 'Mark the begin of a comment\nUsage : ( comment )',
                          ')' : 'Mark the end of comment\nUsage : ( comment )',
                          'cr' : 'Display a carriage return only\nUsage : CR',
                          '.cr' : 'Display the top value of work stack, destroy it and display a carriage return\nUsage : .CR',
                          '.scr' : 'Display the top value of work stack, do not destroy it and display a carriage return\nUsage : .CR',
                          'drop' : 'Drop the top value of work stack\nUsage : ( n ... ) DROP ( ... )',
                          '2drop' : 'Drop the two top values of work stack\nUsage : ( n1 n2 ... ) 2DROP ( ... )',
                          'dump' : 'Dump in console the work stack\nUsage : DUMP',
                          'emit' : 'Display character depending on character code\nUsage : n EMIT',
                          'help' : 'Give you some help on a word\n- Parentheses represent the contents of the working stack.\n- The 3 small dots tell you that the working stack may contain other information\n- You have a representation of the working stack before and after the statement\nUsage : ( ... ) HELP word ( ... )',
                          'import' : 'Import a package and all the words, variables and constants contained in\nUsage : IMPORT package_name',
                          'words' : 'Give you the list of words contained in your dictionnary\nUsage : WORDS',
                          '*' : 'Multiplication operation : not possible between 2 strings\nUsage : ( n1 n2 ... ) * ( n1*n2 ... )',
                          '+' : 'Addition operation : not possible between string and number\nUsage : ( n1 n2 ... ) + ( n1+n2 ... )',
                          '-' : 'Difference operation : not possible between string and number\nUsage : ( n1 n2 ... ) - ( n1-n2 ... )',
                          '/' : 'Division operation : not possible between strings and division by zero is not allowed\nUsage : ( n1 n2 ... ) / ( n1/n2 ... )',
                          '1+' : 'Add 1 to the top value of the work stack and put the result on top of work stack\nUsage : ( n ... ) 1+ ( n+1 ... )',
                          '2+' : 'Add 2 to the top value of the work stack and put the result on top of work stack\nUsage : ( n ... ) 2+ ( n+2 ... )',
                          '1-' : 'Remove 1 to the top value of the work stack and put the result on top of work stack\nUsage : ( n ... ) 1- ( n-1 ... )',
                          '2-' : 'Remove 2 to the top value of the work stack and put the result on top of work stack\nUsage : ( n ... ) 2- ( n-2 ... )',
                          '2*' : 'Multiply 2 to the top value of the work stack and put the result on top of work stack\nUsage : ( n ... ) 2* ( n*2 ... )',
                          'min' : 'Put the min of the two top value of work stack\nUsage : ( n1 n2 ... ) MIN ( min(n1,n2) ... )',
                          'max' : 'Put the min of the two top value of work stack\nUsage : ( n1 n2 ... ) MAX ( max(n1,n2) ... )',
                          'var' : 'Create a new variable\nUsage : ( value ... ) VAR variable_name ( ... ) => variable_name = value in your dictionary',
                          'variables' : 'Give a list of variables\nUsage : VARIABLES',
                          'const' : 'Create a new constant\nUsage : ( value ... ) CONST constant_name ( ... ) => constant_name = value in your dictionary',
                          'constants' : 'Give a list of constants\nUsage : CONSTANTS',
                          '@' : 'Put the value of your variable or constant on top of work stack\nUsage : ( name ... ) @ ( value ... )',
                          '!' : 'Put the top of work stack in a variable content\nUsage : value var_name !',
                          'packages' : 'Give you the list of packages\'s list\nUsage : PACKAGES',
                          'bye' : 'This word to quit Beetle\nUsage : BYE',
                          'see' : 'Display the content of definition\nUsage : SEE def_name',
                          'leave' : 'This word allows you to exit your program at the place where you write it. Not just in a loop\nUsage : LEAVE',
                          'force!' : 'This word force update of constant. Be careful if you use this word, you can compromise system constants\nUsage : ( n constant_name ... ) FORCE! ( ... )',
                          'array' : 'Create an array without words \'[\' and \']\'\nUsage : ( Item_count v1 v2 v3 ... ) ARRAY ( [v1, v2, v3] ... )',
                          '[' : 'Word for creating an indexed array. This word corresponds to the start of the creation sequence\nYou can put the result in a variable or a constant\nUsage : ( ... ) [ v1 v2 v3 ... ] ( [v1, v2, v3, ... ] ... )',
                          ']' : 'Word for closing an indexed array. This word corresponds to the end of the creation sequence\nYou can put the result in a variable or a constant\nUsage : ( ... ) [ v1 v2 v3 ... ] ( [v1, v2, v3, ... ] ... )',
                          '{' : 'Word for creating an hashed array. This word corresponds to the start of the creation sequence\nYou can put the result in a variable or a constant\nUsage : ( ... ) { n1 : v1 , n2 : v2 , n3 : v3 ... } ( { n1: v1, n2: v2, n3: v3, ... } ... )',
                          '}' : 'Word for closing an hashed array. This word corresponds to the end of the creation sequence\nYou can put the result in a variable or a constant\nUsage : ( ... ) { n1 : v1 , n2 : v2 , n3 : v3 ... } ( { n1: v1, n2: v2, n3: v3, ... } ... )',
                          'cell@' : 'Get the value at index position contained in an array\nUsage : ( position (array|var_name|const_name) ... ) CELL@ ( ... )',
                          'cell!' : 'Set the value at index position in an array\nUsage : ( value position array ... ) CELL! ( ... )',
                          'cell+' : 'Appends to the end of an array count entry\nUsage : ( count (array|var_name|const_name) ... ) CELL+ ( ... )',
                          'cell-' : 'Delete the item positioned at the index position of an array\nUsage : ( position (array|var_name|const_name) ... ) CELL- ( ... )',
                          'cells' : 'Count of array content\nUsage : ( array ... ) CELLS ( count ... )',
                          'cell=' : 'Tests the existence of the contents of a table cell\nUsage : ( array content ... ) CELL= ( true | false ... )',
                          'cell?' : 'Writes the contents of a table cell in the console\nUsage : ( array position ... ) CELL? ( ... )',
                          'cells?' : 'Write the count of array content in the console\nUsage : ( array ... ) CELLS? ( ... )',
                          'if' : 'First word of the conditional before area when flag is true\nUsage : flag IF instructions[ ELSE instructions] THEN',
                          'else' : 'First word of the conditional before area when flag is false\nUsage : flag IF instructions[ ELSE instructions] THEN',
                          'do' : 'Start of finited loops\nUsage : limit var_name DO instructions LOOP',
                          'loop' : 'End of finite loops\nUsage : limit var_name DO instructions LOOP',
                          '+loop' : 'End of finite loops with increment\nUsage : limit var_name DO instructions increment +LOOP',
                          'begin' : 'Start of infinited loops\nUsage : BEGIN instructions flag UNTIL',
                          'until' : 'End of infinited loops with stopping condition\nUsage : BEGIN instructions flag UNTIL',
                          'again' : 'End of infinited loops. No stopping condition\nUsage : BEGIN instructions AGAIN',
                          'while' : 'if flag is true, execute instructions2; if flag = false, execute after REPEAT\nUsage : BEGIN instructions1 flag WHILE instructions2 REPEAT',
                          'repeat' : 'Go to BEGIN for executing instructions1\nUsage : BEGIN instructions1 flag WHILE instructions2 REPEAT',
                          'leave' : 'Exits a loop at the place where LEAVE is placed; works for all loops\nUsage : LEAVE',
                          'nip' : 'Remove the second item from the top of the working stack\nUsage : ( n1 n2 ... ) NIP ( n1 ... )', 
                          '2nip' : 'Remove the third and fourth item from the top of the working stack\nUsage : ( n1 n2 n3 n4 ... ) 2NIP ( n1 n2 ... )', 
                          '.2cr' : 'Display the top value of work stack, destroy it and display 2 carriage return\nUsage : ( n ... ) .2CR ( ... )',
                          'true' : 'Represents the Boolean value true and corresponds to the value 1\nIt is a constant and you cannot change its value\nUsage : ( ... ) TRUE ( 1 ... )',
                          'false' : 'Represents the Boolean value false and corresponds to the value 0\nIt is a constant and you cannot change its value\nUsage : ( ... ) FALSE ( 0 ... )', 
                          '0=' : 'Returns true if the tested value is zero\nUsage : ( 0 ... ) 0= ( 1 ... )\n        ( n [!= 0] ... ) 0= ( 0 ... )', 
                          '0>' : 'Returns true if the tested value is greater than zero\nUsage : ( n [> 0] ... ) 0> ( 1 ... )', 
                          '0<' : 'Returns true if the tested value is less than zero\nUsage : ( n [< 0] ... ) 0< ( 1 ... )', 
                          '0>=' : 'Returns true if the tested value is greater than or equal to zero\nUsage : ( n [>= 0] ... ) 0>= ( 1 ... )', 
                          '0<=' : 'Returns true if the tested value is less than or equal to zero\nUsage : ( n [<= 0]... ) 0<= ( 1 ... )', 
                          'invert' : 'Returns the negation of a Boolean value\nUsage : ( 0 ... ) INVERT ( 1 ... )\n        ( 1 ... ) INVERT ( 0 ... )', 
                          '2>r' : 'Put the two top elements of working stack to the top of return stack (rs)\nUsage : ( n1 n2 ... ) 2>R rs( n1 n2 ... )',
                          '2r>' : 'Put the two top eleents of return stack (rs) to the top of working stack\nUsage : rs( n1 n2 ... ) 2R> ( n1 n2 ... )', 
                          'input' : 'Allows the user to interact with the console by authorizing them to enter information\nUsage : ( ... ) INPUT ( s ... )', 
                          'secinput' : 'Allows the user to interact securely with the console by authorizing them to enter information\nWhat is typed by the user is not visible\nUsage : ( ... ) SECINPUT ( s ... )', 
                          '?' : 'Displays the contents of a variable\nUsage : ( v ... ) ? ( ... )', 
                          'negate' : 'Return the negative of a number\nUsage : ( n ... ) NEGATE ( -n ... )',
                          'min' : 'Return the minimum between 2 numbers\nUsage : ( n1 n2 ... ) MIN ( min(n1, n2) ... )',
                          'max' : 'Return the maximum between 2 numbers\nUsage : ( n1 n2 ... ) MAX ( max(n1, n2) ... )',
                          '*/' : 'Perform multiplication and division operations on 3 numbers as follows: (n1 * n2) / n3\nUsage : ( n1 n2 n3 ... ) */ ( n1 * n2 / n3 ... )',
                          '%' : 'This word calculates the n2 percentage of a number n1\nUSAGE : ( n1 n2 ... ) % ( n2%(n1) ... )',
                          '=' : 'Returns true if the 2 top values of working stack are equal\nUsage : ( n1 n2 ... ) = ( 1 [if n1 = n2] ... )\n        ( n1 n2 ... ) = ( 0 [if n1 != n2] ... )', 
                          '<>' : 'Returns true if the 2 top values of working stack are not equal\nUsage : ( n1 n2 ... ) <> ( 1 [if n1 != n2] ... )\n        ( n1 n2 ... ) <> ( 0 [if n1 = n2] ... )',
                          '>' : 'Returns true if one of the 2 top values of working stack is superior to the other\nUsage : ( n1 n2 ... ) > ( 1 [if n1 > n2] ... )\n        ( n1 n2 ... ) > ( 0 [if n1 <= n2] ... )', 
                          '<' : 'Returns true if one of the 2 top values of working stack is inferior to the other\nUsage : ( n1 n2 ... ) < ( 1 [if n1 < n2] ... )\n        ( n1 n2 ... ) < ( 0 [if n1 >= n2] ... )', 
                          '>=' : 'Returns true if one of the 2 top values of working stack is superior or equal to the other\nUsage : ( n1 n2 ... ) >= ( 1 [if n1 >= n2] ... )\n        ( n1 n2 ... ) >= ( 0 [if n1 < n2] ... )', 
                          '<=' : 'Returns true if one of the 2 top values of working stack is inferior or equal to the other\nUsage : ( n1 n2 ... ) <= ( 1 [if n1 <= n2] ... )\n        ( n1 n2 ... ) <= ( 0 [if n1 > n2] ... )',
                          '>r' : 'Put the top of working stack to the top of return stack (rs)\nUsage : ( n ... ) >R rs( n ... )', 
                          'r>' : 'Put the top of return stack (rs) to the top of working stack\nUsage : rs( n ... ) R> ( n ... )',
                          'r@' : 'Removes the item at the top of the return stack to position it at the top of the working stack.\nIf the element is a variable, what is positioned on the working stack is the value of that variable\nUsage : ( n ... ) R@ rs( n ... )', 
                          '@r' : 'Removes the item from the top of the working stack to position it at the top of the return stack.\nIf the element is a variable, what is placed on the return stack is the value of that variable\nUsage : ( n ... ) @R rs( n ... )', 
                          'rdrop' : 'Drop the top value of return stack (rs)\nUsage : rs( n ... ) RDROP rs( ... )', 
                          'rswap' : 'Swap the two top value in return stack (rs)\nUsage : rs( n1 n2 ... ) RSWAP rs( n2 n1 ... )',
                          'rdup' : 'Duplicate the top value in return stack (rs) and put it on top\nUsage : rs( n ... ) RDUP rs( n n ... )', 
                          'rover' : 'Take the second top value in return stack (rs) and put it on the top\nUsage : rs( n1 n2 ... ) ROVER rs( n2 n1 n2 ... )', 
                          'rdump' : 'Dump in console the return stack\nUsage : RDUMP',
                          '+!' : 'Adds a number to the content of a variable\nUsage : ( var_name n ... ) +! ( ... )',
                          '*!' : 'Multiplies a number to the contents of a variable\nUsage : ( var_name n ... ) *! ( ... )',
                          'and' : 'Logical \'and\' very useful in conditionnals\nUsage :\n\t( true true ... ) AND ( true ... )\n\t( true false ... ) AND ( false ... )\n\t( false true ... ) AND ( false ... )\n\t( false false ... ) AND ( false ... )',
                          'or' : 'Logical \'or\' very useful in conditionnals\nUsage :\n\t( true true ... ) OR ( true ... )\n\t( true false ... ) OR ( true ... )\n\t( false true ... ) OR ( true ... )\n\t( false false ... ) OR ( false ... )',
                          'xor' : 'Logical \'xor\' very useful in conditionnals\nUsage :\n\t( true true ... ) XOR ( false ... )\n\t( true false ... ) XOR ( true ... )\n\t( false true ... ) XOR ( true ... )\n\t( false false ... ) XOR ( false ... )',
                          'forget' : 'Allows you to remove any reference to a user-created word or variable\nUsage : ( ... ) FORGET name ( ... )',
                          'cls' : 'Remove all entries from the working stack (CLear Stack)\nUsage : ( ... ) CLS ( )',
                          'clt' : 'Clear the console (CLear Terminal)\nUsage : ( ... ) CLT ( ... )',
                          'create' : 'Creates a new variable or constant in the dictionary\nUsage : ( ... ) CREATE name ( ... )',
                          'does>' : 'Defining automatic instruction execution\nUsage : DOES> instructions',
                          'immediate' : 'This word will allow you to execute the word you are defining within the body of another definition.\nIt will disappear from the definition of that other word.\nUsage: : x .... ; IMMEDIATE',
                          'load' : 'Load and execute the content of a file\nThe filename must be with \'btl\' extension but when you call this word, you must enter the name of the file without the extension\nThe file must be located in the directory whose name is the content of the \'path\' variable\nBy default the content of the variable \'path\' is \'userarea\'\nUsage : ( ... ) LOAD filename ( ... )',
                          'list' : 'Display the content of a file\nThe filename must be with \'btl\' extension but when you call this word, you must enter the name of the file without the extension\nThe file must be located in the directory whose name is the content of the \'path\' variable\nBy default the content of the variable \'path\' is \'userarea\'\nUsage : ( ... ) LIST filename ( ... )',
                          'char' : 'Puts the code of the first character of a string on the working stack\nUsage : ( c ... ) CHAR ( ord(c) ... )',
                          'chars' : 'Adds the number of characters in a string to the working stack\nUsage : ( string ... ) CHARS ( len(string) ... )',
                          'bl' : 'Put a space in working stack\nUsage : ( ... ) BL ( [ ] ... )',
                          'path' : 'The variable that contains the name of the directory containing the Beetle files.\nThe content of this variable can be modified if necessary\nBy default, it contains the \'userarea\' directory',
                          'recurse' : 'Allows you to apply recursion in your definitions',
                          'format' : 'Formats a character string. The formatted character string is placed on the working pile\nThe replacement marker in the character string is: <! for the beginning, !> for the end\nUsage : ( array string ... ) FORMAT ( formatted_string ... )',
                          'base' : 'It is a constant which allows us to know the base in which you are located\nBy default, this constant contains 10\nUsage : ( ... ) BASE ( 10 ... )',
                          'decimal' : 'Allows you to set the base at 10\nUsage : ( ... ) DECIMAL ( ... )',
                          'octal' : 'Allows you to set the base at 8\nUsage : ( ... ) OCTAL ( ... )',
                          'hex' : 'Allows you to set the base at 16\nUsage : ( ... ) HEX ( ... )',
                          'base!' : 'Allows you to set the base at a number between 2 and 36\nUsage : ( ... ) BASE! ( ... )',
                          '>base' : 'Converts a base 10 number to a base n 2 <= n <= 36 number\nUsage : ( newbase number_in_base_10 ... ) >BASE ( number_in_base_n ... )',
                          '>decimal' : 'Converts a number in base n != 10 into a number in base 10\nUsage : ( string base ... ) >DECIMAL ( number_in_base_10 ... )',
                          '?int' : 'Indicates whether the top of working stack number is an integer\nUsage : ( n ... ) ?INT ( int(n) ... )',
                          '?float' : 'Indicates whether the top of working stack number is a float\nUsage : ( n ... ) ?FLOAT ( float(n) ... )',
                          '?str' : 'Indicates whether the top of working stack is a string\nUsage : ( n ... ) ?STR ( str(n) ... )',
                          '?char' : 'Indicates whether the top of working stack is a char\nUsage : ( n ... ) ?CHAR ( char(n) ... )',
                          '?array' : 'Indicates whether the top of working stack is an array\nUsage : ( n ... ) ?ARRAY ( array(n) ... )',
                          '?pack' : 'Indicates whether the top of working stack is the name of a package\nUsage : ( n ... ) ?PACK ( pack(n) ... )',
                          '?def' : 'Indicates whether the top of working stack is the name of a definition\nUsage : ( "n" ... ) ?DEF ( def("n") ... )',
                          '?var' : 'Indicates whether the top of working stack is the name of a global variable\nUsage : ( n ... ) ?VAR ( var(n) ... )',
                          '?local' : 'Indicates whether the top of working stack is the name of a local variable\nUsage : ( n ... ) ?LOCAL ( local(n) ... )',
                          'wp' : 'Indicates the address of the next element in the working stack\nUsage : ( ... ) WP ( pointer ... )',
                          'sp' : 'Indicates the address of the next element in the sequence\nUsage : ( ... ) SP ( pointer ... )',
                          'vp' : 'Indicates the address of the next dictionary element\nUsage : ( ... ) VP ( pointer ... )',
                          'kpress' : 'Allows the user to control the keyboard many time\nUsage : ( key ... ) KPRESS ( true | false ... )',
                          'readk' : 'Allows the user to control the keyboard one time\nUsage : ( key ... ) READK ( true | false ... )',
                          'space' : 'Constant representing the space character code\nUsage : ( ... ) SPACE ( 32 ... )',
                          't{' : 'This word represents the beginning of a test sequence. This sequence must end with the word }t\nUsage : t{ ... -> ... }t',
                          '}t' : 'This word represents the end of a test sequence. see also help of the word t{\nUsage : t{ ... -> ... }t',
                          '->' : 'This word compares the stacks that are in a test sequence\nUsage : t{ ... -> ... }t'}
