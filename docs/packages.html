<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Packages</title>
        <!--<link rel="stylesheet" href="main.css">-->
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <div class="div_logo">
            <img src="images/logo.png" width="250"/>
        </div>
        <div class="div_title">
            <h1>VI. Packages</h1>
        </div>
        <div style="clear:both;"><hr></div>

        <p><a href="dictionaries.html">Précédent : V. Dictionnaires</a> | <a href="index.html">Index</a> | <a href="console.html">Suivant : VII. Console</a></p>

        <p>
            Nous vous proposons une méthodologie pour créer de nouveaux packages. Il est important que vous suiviez cette 
            procédure au risque que vos efforts ne soient pas couronnés de succès.
        </p>
        <p>
            Vous devez fabriquer une classe qui représente votre package dans un fichier que <b>vous placerez impérativement dans le 
            répertoire 'packages' de Beetle</b>. Le nom de votre fichier doit porter le même nom que votre classe
            Et votre package ne doit comporter qu'une seule classe pour représenter votre package.
            Vous pouvez avoir plusieurs classes dans ce fichier mais seule la classe qui porte le même nom que votre 
            fichier représente votre package
        </p>
        <p>Vous avez l'obligation d'utiliser Python pour écrire votre nouveau package.</p>
        <p>Voici un modèle de classe pour votre futur package (<b>myextension.py</b>) :</p>
        <div class="div_code">
            <code>
                from packages.base_module import base_module # this is mandatory<br>
                from packages.help.myextension_help import myextension_help<br>
                from packages.errors.myextension_errors import myextension_errors<br>
                <br>
                class <b>myextension</b>(base_module):<br>
                    <blockquote>def __init__(self, interpreter):<br>
                        <blockquote>super().__init__(interpreter)<br>
                        self.dictionary = {'myinstruction' : self.my_instr, ...}<br>
                        self.help = myextension_help(interpreter.output)<br>
                        self.version = 'vx.y.z'<br>
                        self.packuse = ['package1', 'package2', ...]<br>
                        </blockquote>
                        <br>
                    def my_instr(self):<br>
                        <blockquote>#<br>
                        # you do here what you want<br>
                        #<br>
                        return 'nobreak'                            # mandatory if you don't use error
                        </blockquote>
                    </blockquote>
            </code>
        </div>

        <p>
            L'attribut de classe '<b>packuse</b>' vous permet de déclarer des dépendances entre ce package et les autres packages éxistants.
            Le processus de chargement des packages est récursif. Ceci est très pratique et vous permet de ne pas vous soucier des
            packages qui doivent être chargés systématiquement.<br>
            Exemple : le package 'web' utilise les packages 'mysqldb' et 'mail'
        </p>
        <p>Mais cela ne s'arrête pas la. Il vous faudra également créer 2 autres classes pour faire fonctionner votre nouveau package.</p>
        <p>Ces classes sont :</p>
        <ul>
            <li>la classe <b><i>myextension</i>_errors</b> que vous devrez placer dans le répertoire 'packages/errors'</li>
            <li>la classe <b><i>myextension</i>_help</b> que vous devrez placer dans le répertoire 'packages/help'</li>
        </ul>
        <p>La classe concernant les erreurs de votre package ressemble à cela (<b>myextension_errors.py</b>) :</p>            
        
        <div class="div_code">
            <code>
                from packages.errors.errors import error<br>
                <br>
                class <b>myextension_errors</b>:<br>
                <blockquote>my_error_name = error(error_type, error_message)<br>
                    ...<br>
                    <br>
                    # error_type = 'warning' or 'error' or 'fatal' : fatal error_type stop the Beetle interpreter<br>
                    # error_message is a string like vous want to say
                </blockquote>
            </code>
        </div>
        <p>Exemple de fichier erreurs du package 'file' (<b>file_errors.py</b>) :</p>            
        <div class="div_code">
            <code>
                from packages.errors.errors import error<br><br>

                class file_errors:<br>
                <blockquote>
                    error_open_file_failed = error('fatal', 'this file doesn\'t exists')<br>
                    error_not_a_file_descriptor = error('error', 'not a file descriptor')<br>
                    error_end_of_content_missing = error('error', 'end of content missing')<br>
                    error_end_of_content_work_with_begin_of_content = error('error', 'end of content work with begin of content')
                </blockquote>
            </code>
        </div>
            
        <p>L'aide de votre extension doit être défini dans une nouvelle classe. C'est en réalité un dictionnaire que vous plcerez ans un fichier qui se nomme de cette façon : <b>myextension_help.py</b>.</p>
            
        <p>Son contenu est :</p>
            
        <div class="div_code">
            <code>
            from packages.help.help import help<br><br>
            class <b>myextension_help</b>(help):<br>
            <blockquote>def __init__(self, output):
                <blockquote>super().__init__(output)<br>
                    self.help_dict = {'myinstruction' : help_message, ...}<br>
                    # help_message is a string
                </blockquote>
            </blockquote>
            </code>
        </div>

        <p>Exemple de fichier aide du package 'file' (<b>file_help.py</b>) :</p>            
        <div class="div_code">
            <code>
            from packages.help.help import help<br><br>

            class file_help(help):<br>
            <blockquote>
                def __init__(self, output):<br>
                <blockquote>
                    super().__init__(output)<br>
                    self.help_dict = {'appendtofile' : 'Open file in writing mode append. If file doesn\'t exists, it will be created\nUsage : ( descriptor_name filename ... ) APPENDTOFILE ( ... )',<br>
                    <blockquote>
                                    'overwritetofile' : 'Open file in writing mode write. If file doesn\'t exists, it will be created\nUsage : ( descriptor_name filename ... ) OVERWRITETOFILE ( ... )',<br>
                                    'readingfile' : 'Open file in reading mode. If file doesn\'t exists, an error will be raised\nUsage : ( descriptor_name filename ... ) READINDFILE ( ... )',<br>
                                    'closefile' : 'Close file\nUsage : ( descriptor_name ... ) CLOSEFILE ( ... )',<br>
                                    'writein' : 'Write something in a file\nUsage : ( descriptor_name content ... ) WRITEIN ( ... )',<br>
                                    'readfile' : 'File entire reading and put it in the top of data stack\nUsage : ( descriptor_name ... ) READFILE ( content ... )',<br>
                                    'readline' : 'File reading by line and put it in the top of data stack\nUsage : ( descriptor_name ... ) READLINE ( content ... )',<br>
                                    'readchar' : 'File reading by character and put it in the top of data stack\nUsage : ( descriptor_name ... ) READCHAR ( content ... )'}
                    </blockquote>
                </blockquote>
            </blockquote>
            </code>
        </div>

        <p><a href="dictionaries.html">Précédent : V. Dictionnaires</a> | <a href="index.html">Index</a> | <a href="console.html">Suivant : VII. Console</a></p>

    </body>
</html>